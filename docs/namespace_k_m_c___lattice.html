<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Excimontec: KMC_Lattice Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Excimontec
   &#160;<span id="projectnumber">v1.0.0</span>
   </div>
   <div id="projectbrief">An open-source KMC simulation software package for modeling the optoelectronic processes in organic semiconductor materials and devices, such as OPVs, OLEDs, and more.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_k_m_c___lattice.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">KMC_Lattice Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_k_m_c___lattice_1_1_coords.html">Coords</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This simple struct contains Cartesian coordinates specified by integers x,y,z.  <a href="struct_k_m_c___lattice_1_1_coords.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_k_m_c___lattice_1_1_event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class contains the basic properties of a KMC simulation event and the functions needed to interact with it.  <a href="class_k_m_c___lattice_1_1_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_k_m_c___lattice_1_1_lattice.html">Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the properties of a three-dimensional lattice and the functions needed to interact with it.  <a href="class_k_m_c___lattice_1_1_lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_k_m_c___lattice_1_1_object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class contains the basic properties of a KMC simulation object and the functions needed to interact with it.  <a href="class_k_m_c___lattice_1_1_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_k_m_c___lattice_1_1_parameters___lattice.html">Parameters_Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the main input parameters needed by the <a class="el" href="class_k_m_c___lattice_1_1_lattice.html" title="This class contains the properties of a three-dimensional lattice and the functions needed to interac...">Lattice</a> class.  <a href="class_k_m_c___lattice_1_1_parameters___lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_k_m_c___lattice_1_1_parameters___simulation.html">Parameters_Simulation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the main input parameters needed by the <a class="el" href="class_k_m_c___lattice_1_1_simulation.html" title="This abstract base class contains the basic properties of a KMC simulation and the functions needed t...">Simulation</a> class.  <a href="class_k_m_c___lattice_1_1_parameters___simulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_k_m_c___lattice_1_1_simulation.html">Simulation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract base class contains the basic properties of a KMC simulation and the functions needed to interact with it.  <a href="class_k_m_c___lattice_1_1_simulation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_k_m_c___lattice_1_1_site.html">Site</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base class contains the basic properties of a lattice site and the functions needed to interact with it.  <a href="class_k_m_c___lattice_1_1_site.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_k_m_c___lattice_1_1_version.html">Version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the current version information and version comparison operators.  <a href="class_k_m_c___lattice_1_1_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad2e814dca455b05c932ca233a7e86a04"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#ad2e814dca455b05c932ca233a7e86a04">calculateCumulativeHist</a> (const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;hist)</td></tr>
<tr class="memdesc:ad2e814dca455b05c932ca233a7e86a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cumulative histogram from the input probability histogram data.  <a href="#ad2e814dca455b05c932ca233a7e86a04">More...</a><br /></td></tr>
<tr class="separator:ad2e814dca455b05c932ca233a7e86a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa8fb79d61e6a76cea8746e4a558c34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a6fa8fb79d61e6a76cea8746e4a558c34">calculateDensityHist</a> (const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;hist)</td></tr>
<tr class="memdesc:a6fa8fb79d61e6a76cea8746e4a558c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the density histogram from the input probability histogram.  <a href="#a6fa8fb79d61e6a76cea8746e4a558c34">More...</a><br /></td></tr>
<tr class="separator:a6fa8fb79d61e6a76cea8746e4a558c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1be59b03325e1ed725fadea7209d53"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#aed1be59b03325e1ed725fadea7209d53">calculateHist</a> (const std::vector&lt; int &gt; &amp;data, int bin_size)</td></tr>
<tr class="memdesc:aed1be59b03325e1ed725fadea7209d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the histogram for the input integer data vector using the input bin size.  <a href="#aed1be59b03325e1ed725fadea7209d53">More...</a><br /></td></tr>
<tr class="separator:aed1be59b03325e1ed725fadea7209d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc79e61f39b75c10f5d9ac3cfc65d6d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#addc79e61f39b75c10f5d9ac3cfc65d6d">calculateProbabilityHist</a> (const std::vector&lt; std::pair&lt; double, int &gt;&gt; hist)</td></tr>
<tr class="memdesc:addc79e61f39b75c10f5d9ac3cfc65d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the probability histogram for the input histogram data vector. The function outputs bin-centered x values and probability y values in a x-y pair vector.  <a href="#addc79e61f39b75c10f5d9ac3cfc65d6d">More...</a><br /></td></tr>
<tr class="separator:addc79e61f39b75c10f5d9ac3cfc65d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b5963ba2a0bfe3cd50adbb95738e8c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#ae9b5963ba2a0bfe3cd50adbb95738e8c">calculateProbabilityHist</a> (const std::vector&lt; int &gt; &amp;data, int bin_size)</td></tr>
<tr class="memdesc:ae9b5963ba2a0bfe3cd50adbb95738e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the probability histogram for the input integer data vector using the input bin size.  <a href="#ae9b5963ba2a0bfe3cd50adbb95738e8c">More...</a><br /></td></tr>
<tr class="separator:ae9b5963ba2a0bfe3cd50adbb95738e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051fca5d8418abdc2189d1751a093561"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a051fca5d8418abdc2189d1751a093561">calculateProbabilityHist</a> (const std::vector&lt; double &gt; &amp;data, int num_bins)</td></tr>
<tr class="memdesc:a051fca5d8418abdc2189d1751a093561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the probability histogram for the input double data vector using the input number of bins.  <a href="#a051fca5d8418abdc2189d1751a093561">More...</a><br /></td></tr>
<tr class="separator:a051fca5d8418abdc2189d1751a093561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52cf3ac9ea9dafde2c32b724f0cedc9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#ac52cf3ac9ea9dafde2c32b724f0cedc9">calculateProbabilityHist</a> (const std::vector&lt; float &gt; &amp;data, int num_bins)</td></tr>
<tr class="memdesc:ac52cf3ac9ea9dafde2c32b724f0cedc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the probability histogram for the input float data vector using the input number of bins.  <a href="#ac52cf3ac9ea9dafde2c32b724f0cedc9">More...</a><br /></td></tr>
<tr class="separator:ac52cf3ac9ea9dafde2c32b724f0cedc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dce0ac44cb8f91ab6ecaf6d40ed25f9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a4dce0ac44cb8f91ab6ecaf6d40ed25f9">calculateProbabilityHist</a> (const std::vector&lt; double &gt; &amp;data, double bin_size)</td></tr>
<tr class="memdesc:a4dce0ac44cb8f91ab6ecaf6d40ed25f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the probability histogram for the input double data vector using the input bin size.  <a href="#a4dce0ac44cb8f91ab6ecaf6d40ed25f9">More...</a><br /></td></tr>
<tr class="separator:a4dce0ac44cb8f91ab6ecaf6d40ed25f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c914a7aceae31c54b678dddd04ea84"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a38c914a7aceae31c54b678dddd04ea84">calculateProbabilityHist</a> (const std::vector&lt; float &gt; &amp;data, double bin_size)</td></tr>
<tr class="memdesc:a38c914a7aceae31c54b678dddd04ea84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the probability histogram for the input float data vector using the input bin size.  <a href="#a38c914a7aceae31c54b678dddd04ea84">More...</a><br /></td></tr>
<tr class="separator:a38c914a7aceae31c54b678dddd04ea84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e38c07261ec4b14f0c60020e56d9493"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a0e38c07261ec4b14f0c60020e56d9493">calculateProbabilityHist</a> (const std::vector&lt; double &gt; &amp;data, const double bin_size, const int num_bins)</td></tr>
<tr class="memdesc:a0e38c07261ec4b14f0c60020e56d9493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the probability histogram for the input double data vector using the input bin size and input number of bins.  <a href="#a0e38c07261ec4b14f0c60020e56d9493">More...</a><br /></td></tr>
<tr class="separator:a0e38c07261ec4b14f0c60020e56d9493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfdace4de266128171220d8814d1adb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a2cfdace4de266128171220d8814d1adb">calculateProbabilityHist</a> (const std::vector&lt; float &gt; &amp;data, const double bin_size, const int num_bins)</td></tr>
<tr class="memdesc:a2cfdace4de266128171220d8814d1adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the probability histogram for the input float data vector using the input bin size and input number of bins.  <a href="#a2cfdace4de266128171220d8814d1adb">More...</a><br /></td></tr>
<tr class="separator:a2cfdace4de266128171220d8814d1adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56deb6fcc363eed85073043ff129297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#ad56deb6fcc363eed85073043ff129297">createExponentialDOSVector</a> (std::vector&lt; double &gt; &amp;data, const double mode, const double urbach_energy, std::mt19937_64 &amp;gen)</td></tr>
<tr class="memdesc:ad56deb6fcc363eed85073043ff129297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector of doubles that has a custom asymmetric distribution with an exponential tail.  <a href="#ad56deb6fcc363eed85073043ff129297">More...</a><br /></td></tr>
<tr class="separator:ad56deb6fcc363eed85073043ff129297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ace7172f1130a049e6069ba6d403fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a34ace7172f1130a049e6069ba6d403fc">createExponentialDOSVector</a> (std::vector&lt; float &gt; &amp;data, const double mode, const double urbach_energy, std::mt19937_64 &amp;gen)</td></tr>
<tr class="memdesc:a34ace7172f1130a049e6069ba6d403fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector of floats that has a custom asymmetric distribution with an exponential tail.  <a href="#a34ace7172f1130a049e6069ba6d403fc">More...</a><br /></td></tr>
<tr class="separator:a34ace7172f1130a049e6069ba6d403fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a253f2ce23a5a608d582a06e67d852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a58a253f2ce23a5a608d582a06e67d852">createGaussianDOSVector</a> (std::vector&lt; double &gt; &amp;data, const double mean, const double stdev, std::mt19937_64 &amp;gen)</td></tr>
<tr class="memdesc:a58a253f2ce23a5a608d582a06e67d852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector of doubles that has a Gaussian distribution.  <a href="#a58a253f2ce23a5a608d582a06e67d852">More...</a><br /></td></tr>
<tr class="separator:a58a253f2ce23a5a608d582a06e67d852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224863c8dd449fa501d07c5b0cfc07a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a224863c8dd449fa501d07c5b0cfc07a1">createGaussianDOSVector</a> (std::vector&lt; float &gt; &amp;data, const double mean, const double stdev, std::mt19937_64 &amp;gen)</td></tr>
<tr class="memdesc:a224863c8dd449fa501d07c5b0cfc07a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector of floats that has a Gaussian distribution.  <a href="#a224863c8dd449fa501d07c5b0cfc07a1">More...</a><br /></td></tr>
<tr class="separator:a224863c8dd449fa501d07c5b0cfc07a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0f0e2e47c9dbe650e4f736c80883c3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a0b0f0e2e47c9dbe650e4f736c80883c3">integrateData</a> (const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;data)</td></tr>
<tr class="memdesc:a0b0f0e2e47c9dbe650e4f736c80883c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerically integrates a vector of x-y data using the trapezoid rule.  <a href="#a0b0f0e2e47c9dbe650e4f736c80883c3">More...</a><br /></td></tr>
<tr class="separator:a0b0f0e2e47c9dbe650e4f736c80883c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c980223b98303984f9c722356101eb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a04c980223b98303984f9c722356101eb">interpolateData</a> (const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;data, const double x_val)</td></tr>
<tr class="memdesc:a04c980223b98303984f9c722356101eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly interpolates an x-y data set to determine the interpolated y-value corresponding to an input x-value.  <a href="#a04c980223b98303984f9c722356101eb">More...</a><br /></td></tr>
<tr class="separator:a04c980223b98303984f9c722356101eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59934977c80ff0ef20e4108ed0e859a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#ac59934977c80ff0ef20e4108ed0e859a">MPI_calculatePairVectorAvg</a> (const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;input_vector)</td></tr>
<tr class="memdesc:ac59934977c80ff0ef20e4108ed0e859a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses MPI to calculate the average pair vector distribution from separate pair vectors coming from different processors.  <a href="#ac59934977c80ff0ef20e4108ed0e859a">More...</a><br /></td></tr>
<tr class="separator:ac59934977c80ff0ef20e4108ed0e859a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb87c0ce18e46b80e482ab257345f70c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#acb87c0ce18e46b80e482ab257345f70c">MPI_calculateProbHistAvg</a> (const std::vector&lt; std::pair&lt; double, int &gt;&gt; &amp;input_hist)</td></tr>
<tr class="memdesc:acb87c0ce18e46b80e482ab257345f70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses MPI to calculate the average probability histogram from separate histograms coming from different processors.  <a href="#acb87c0ce18e46b80e482ab257345f70c">More...</a><br /></td></tr>
<tr class="separator:acb87c0ce18e46b80e482ab257345f70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad022d008e8635c1285b9b2ca300bd5b6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#ad022d008e8635c1285b9b2ca300bd5b6">MPI_calculateVectorAvg</a> (const std::vector&lt; double &gt; &amp;input_vector)</td></tr>
<tr class="memdesc:ad022d008e8635c1285b9b2ca300bd5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses MPI to calculate the element-wise average vector from separate vectors coming from different processors.  <a href="#ad022d008e8635c1285b9b2ca300bd5b6">More...</a><br /></td></tr>
<tr class="separator:ad022d008e8635c1285b9b2ca300bd5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b88bbdb7d17543f266c0ec41bfc3b8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#aa1b88bbdb7d17543f266c0ec41bfc3b8">MPI_calculateVectorSum</a> (const std::vector&lt; double &gt; &amp;input_vector)</td></tr>
<tr class="memdesc:aa1b88bbdb7d17543f266c0ec41bfc3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses MPI to calculate the element-wise sum vector from separate equally sized vectors coming from different processors.  <a href="#aa1b88bbdb7d17543f266c0ec41bfc3b8">More...</a><br /></td></tr>
<tr class="separator:aa1b88bbdb7d17543f266c0ec41bfc3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd5796fdd773483e11f6b3e0a954821"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#aafd5796fdd773483e11f6b3e0a954821">MPI_calculateVectorSum</a> (const std::vector&lt; int &gt; &amp;input_vector)</td></tr>
<tr class="memdesc:aafd5796fdd773483e11f6b3e0a954821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses MPI to calculate the element-wise sum vector from separate vectors coming from different processors.  <a href="#aafd5796fdd773483e11f6b3e0a954821">More...</a><br /></td></tr>
<tr class="separator:aafd5796fdd773483e11f6b3e0a954821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3edfa485575cfb88a6fac4ebec2ee8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a6b3edfa485575cfb88a6fac4ebec2ee8">MPI_gatherValues</a> (const int input_val)</td></tr>
<tr class="memdesc:a6b3edfa485575cfb88a6fac4ebec2ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses MPI to gather integer values from separate processors to build one vector containing all of the data.  <a href="#a6b3edfa485575cfb88a6fac4ebec2ee8">More...</a><br /></td></tr>
<tr class="separator:a6b3edfa485575cfb88a6fac4ebec2ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2e9d9c5fa55962da8329cae7787a61"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#add2e9d9c5fa55962da8329cae7787a61">MPI_gatherValues</a> (const double input_val)</td></tr>
<tr class="memdesc:add2e9d9c5fa55962da8329cae7787a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses MPI to gather double values from separate processors to build one vector containing all of the data.  <a href="#add2e9d9c5fa55962da8329cae7787a61">More...</a><br /></td></tr>
<tr class="separator:add2e9d9c5fa55962da8329cae7787a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d250b1fe5dc4ca3bc72babcede6c664"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a4d250b1fe5dc4ca3bc72babcede6c664">MPI_gatherVectors</a> (const std::vector&lt; double &gt; &amp;input_vector)</td></tr>
<tr class="memdesc:a4d250b1fe5dc4ca3bc72babcede6c664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses MPI to gather vectors from separate processors to build one big vector containing all of the data.  <a href="#a4d250b1fe5dc4ca3bc72babcede6c664">More...</a><br /></td></tr>
<tr class="separator:a4d250b1fe5dc4ca3bc72babcede6c664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2446260a5a686ab9d49f0a765f79bb72"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a2446260a5a686ab9d49f0a765f79bb72">MPI_gatherVectors</a> (const std::vector&lt; int &gt; &amp;input_vector)</td></tr>
<tr class="memdesc:a2446260a5a686ab9d49f0a765f79bb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses MPI to gather vectors from separate processors to build one big vector containing all of the data.  <a href="#a2446260a5a686ab9d49f0a765f79bb72">More...</a><br /></td></tr>
<tr class="separator:a2446260a5a686ab9d49f0a765f79bb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142c78315f934d0d4a046faa564621ee"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a142c78315f934d0d4a046faa564621ee">removeWhitespace</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a142c78315f934d0d4a046faa564621ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all spaces and tab characters in a string.  <a href="#a142c78315f934d0d4a046faa564621ee">More...</a><br /></td></tr>
<tr class="separator:a142c78315f934d0d4a046faa564621ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106d596e3fdd800dd2bc451ab3a0cc92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a106d596e3fdd800dd2bc451ab3a0cc92">round_int</a> (const double num)</td></tr>
<tr class="memdesc:a106d596e3fdd800dd2bc451ab3a0cc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the input double value to the nearest integer value.  <a href="#a106d596e3fdd800dd2bc451ab3a0cc92">More...</a><br /></td></tr>
<tr class="separator:a106d596e3fdd800dd2bc451ab3a0cc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cf4b636d0653f1e68b9035ae63a6f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a82cf4b636d0653f1e68b9035ae63a6f8">str2bool</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a82cf4b636d0653f1e68b9035ae63a6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a boolean value from a string containing "true" or "false". Throws an invalid_argument exception if the input string is not "true" or "false".  <a href="#a82cf4b636d0653f1e68b9035ae63a6f8">More...</a><br /></td></tr>
<tr class="separator:a82cf4b636d0653f1e68b9035ae63a6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab019150ae3696a9d3a886b65122d796d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab019150ae3696a9d3a886b65122d796d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#ab019150ae3696a9d3a886b65122d796d">array_avg</a> (const T data[], const int array_size)</td></tr>
<tr class="memdesc:ab019150ae3696a9d3a886b65122d796d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function calculates and returns the average value in double format when given an array of numerical datatypes.  <a href="#ab019150ae3696a9d3a886b65122d796d">More...</a><br /></td></tr>
<tr class="separator:ab019150ae3696a9d3a886b65122d796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9370e8254289e409fa976c01a4897493"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9370e8254289e409fa976c01a4897493"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a9370e8254289e409fa976c01a4897493">array_median</a> (const T data[], const int array_size)</td></tr>
<tr class="memdesc:a9370e8254289e409fa976c01a4897493"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function calculates and returns the median value when given an array of numerical datatypes.  <a href="#a9370e8254289e409fa976c01a4897493">More...</a><br /></td></tr>
<tr class="separator:a9370e8254289e409fa976c01a4897493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f3987c45a61ea9cd9a8868f846c57c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21f3987c45a61ea9cd9a8868f846c57c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a21f3987c45a61ea9cd9a8868f846c57c">array_stdev</a> (const T data[], const int array_size)</td></tr>
<tr class="memdesc:a21f3987c45a61ea9cd9a8868f846c57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function calculates and returns the standard deviation in double format when given an array of numerical datatypes.  <a href="#a21f3987c45a61ea9cd9a8868f846c57c">More...</a><br /></td></tr>
<tr class="separator:a21f3987c45a61ea9cd9a8868f846c57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cae8fc542c8b178e0a41c879e54328"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90cae8fc542c8b178e0a41c879e54328"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a90cae8fc542c8b178e0a41c879e54328">array_which_median</a> (const T data[], const int array_size)</td></tr>
<tr class="memdesc:a90cae8fc542c8b178e0a41c879e54328"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function determines which element in the data array has the median value of the dataset.  <a href="#a90cae8fc542c8b178e0a41c879e54328">More...</a><br /></td></tr>
<tr class="separator:a90cae8fc542c8b178e0a41c879e54328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d94bc0d678c87d936e14a53c3094ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87d94bc0d678c87d936e14a53c3094ff"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a87d94bc0d678c87d936e14a53c3094ff">intpow</a> (const T base, const int exponent)</td></tr>
<tr class="memdesc:a87d94bc0d678c87d936e14a53c3094ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function calculates and returns the results of an integer power operation on a base numerical datatype.  <a href="#a87d94bc0d678c87d936e14a53c3094ff">More...</a><br /></td></tr>
<tr class="separator:a87d94bc0d678c87d936e14a53c3094ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56238d005a2124d1d05e06a927da171d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56238d005a2124d1d05e06a927da171d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a56238d005a2124d1d05e06a927da171d">outputVectorToFile</a> (std::vector&lt; T &gt; &amp;vec, std::string filename)</td></tr>
<tr class="memdesc:a56238d005a2124d1d05e06a927da171d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function outputs the input data vector to a file with the specified filename.  <a href="#a56238d005a2124d1d05e06a927da171d">More...</a><br /></td></tr>
<tr class="separator:a56238d005a2124d1d05e06a927da171d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e4511b3bf639f465a6a5ab4511f266"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99e4511b3bf639f465a6a5ab4511f266"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a99e4511b3bf639f465a6a5ab4511f266">outputVectorToFile</a> (std::vector&lt; std::pair&lt; T, T &gt;&gt; &amp;vec, std::string filename)</td></tr>
<tr class="memdesc:a99e4511b3bf639f465a6a5ab4511f266"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function outputs the input data pair vector to a file with the specified filename.  <a href="#a99e4511b3bf639f465a6a5ab4511f266">More...</a><br /></td></tr>
<tr class="separator:a99e4511b3bf639f465a6a5ab4511f266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5855f0270f9168564452bdc258c0c24c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5855f0270f9168564452bdc258c0c24c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a5855f0270f9168564452bdc258c0c24c">removeDuplicates</a> (std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a5855f0270f9168564452bdc258c0c24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function efficiently removes the duplicate entries from an input vector.  <a href="#a5855f0270f9168564452bdc258c0c24c">More...</a><br /></td></tr>
<tr class="separator:a5855f0270f9168564452bdc258c0c24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e3c50cbe381912063d9a263a1421a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ac6e3c50cbe381912063d9a263a1421a8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#ac6e3c50cbe381912063d9a263a1421a8">vector_avg</a> (const std::vector&lt; T, A &gt; &amp;data)</td></tr>
<tr class="memdesc:ac6e3c50cbe381912063d9a263a1421a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function calculates and returns the average value in double format when given a vector of numerical datatypes.  <a href="#ac6e3c50cbe381912063d9a263a1421a8">More...</a><br /></td></tr>
<tr class="separator:ac6e3c50cbe381912063d9a263a1421a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bbe80a35ef2c48aedb10c350f9281a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a09bbe80a35ef2c48aedb10c350f9281a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a09bbe80a35ef2c48aedb10c350f9281a">vector_median</a> (std::vector&lt; T, A &gt; data)</td></tr>
<tr class="memdesc:a09bbe80a35ef2c48aedb10c350f9281a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function calculates and returns the median value when given a vector of numerical datatypes.  <a href="#a09bbe80a35ef2c48aedb10c350f9281a">More...</a><br /></td></tr>
<tr class="separator:a09bbe80a35ef2c48aedb10c350f9281a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650b567dda3d6dbfc9290ac200af0954"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a650b567dda3d6dbfc9290ac200af0954"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a650b567dda3d6dbfc9290ac200af0954">vector_stdev</a> (const std::vector&lt; T, A &gt; &amp;data)</td></tr>
<tr class="memdesc:a650b567dda3d6dbfc9290ac200af0954"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function calculates and returns the standard deviation in double format when given a vector of numerical datatypes.  <a href="#a650b567dda3d6dbfc9290ac200af0954">More...</a><br /></td></tr>
<tr class="separator:a650b567dda3d6dbfc9290ac200af0954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cb31c44a91bf42258b5539fc42563e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:aa5cb31c44a91bf42258b5539fc42563e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#aa5cb31c44a91bf42258b5539fc42563e">vector_which_median</a> (const std::vector&lt; T, A &gt; &amp;data)</td></tr>
<tr class="memdesc:aa5cb31c44a91bf42258b5539fc42563e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template function determines which element in the data vector is closest to the median value of the dataset.  <a href="#aa5cb31c44a91bf42258b5539fc42563e">More...</a><br /></td></tr>
<tr class="separator:aa5cb31c44a91bf42258b5539fc42563e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8436fee117116a8b56d91501d4aa6295"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a8436fee117116a8b56d91501d4aa6295">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_k_m_c___lattice_1_1_version.html">Version</a> &amp;input)</td></tr>
<tr class="separator:a8436fee117116a8b56d91501d4aa6295"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a91f4a916d9235dfa664004930666c9fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_k_m_c___lattice_1_1_version.html">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_k_m_c___lattice.html#a91f4a916d9235dfa664004930666c9fa">Current_version</a> (&quot;2.1.0-beta.1&quot;)</td></tr>
<tr class="separator:a91f4a916d9235dfa664004930666c9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab019150ae3696a9d3a886b65122d796d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab019150ae3696a9d3a886b65122d796d">&#9670;&nbsp;</a></span>array_avg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KMC_Lattice::array_avg </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>array_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function calculates and returns the average value in double format when given an array of numerical datatypes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the array of numerical data. </td></tr>
    <tr><td class="paramname">array_size</td><td>is the size of the input data array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the data set in double format. </dd></dl>

</div>
</div>
<a id="a9370e8254289e409fa976c01a4897493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9370e8254289e409fa976c01a4897493">&#9670;&nbsp;</a></span>array_median()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T KMC_Lattice::array_median </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>array_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function calculates and returns the median value when given an array of numerical datatypes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the array of numerical data. </td></tr>
    <tr><td class="paramname">array_size</td><td>is the size of the input data array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The median value of the data set. </dd></dl>

</div>
</div>
<a id="a21f3987c45a61ea9cd9a8868f846c57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f3987c45a61ea9cd9a8868f846c57c">&#9670;&nbsp;</a></span>array_stdev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KMC_Lattice::array_stdev </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>array_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function calculates and returns the standard deviation in double format when given an array of numerical datatypes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the input array of numerical data. </td></tr>
    <tr><td class="paramname">array_size</td><td>is the size of the input data array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The standard deviation of the data set in double format. </dd></dl>

</div>
</div>
<a id="a90cae8fc542c8b178e0a41c879e54328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cae8fc542c8b178e0a41c879e54328">&#9670;&nbsp;</a></span>array_which_median()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int KMC_Lattice::array_which_median </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>array_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function determines which element in the data array has the median value of the dataset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the input array of numerical data. </td></tr>
    <tr><td class="paramname">array_size</td><td>is the size of the input data array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integer array index that indicates the median value. </dd>
<dd>
-1 if the median cannot be determined. </dd></dl>

</div>
</div>
<a id="ad2e814dca455b05c932ca233a7e86a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e814dca455b05c932ca233a7e86a04">&#9670;&nbsp;</a></span>calculateCumulativeHist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::calculateCumulativeHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>hist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the cumulative histogram from the input probability histogram data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>is the input probability histogram which is a vector of x-y pairs consisting of bin-centered x values and probability y values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of x-y pairs consisting of bin-centered x values and cumulative probability y values. </dd></dl>

</div>
</div>
<a id="a6fa8fb79d61e6a76cea8746e4a558c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa8fb79d61e6a76cea8746e4a558c34">&#9670;&nbsp;</a></span>calculateDensityHist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::calculateDensityHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>hist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the density histogram from the input probability histogram. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>is the input probability histogram which is a vector of x-y pairs consisting of bin-centered x values and probability y values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of x-y pairs consisting of bin-centered x values and probability density y values. </dd></dl>

</div>
</div>
<a id="aed1be59b03325e1ed725fadea7209d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1be59b03325e1ed725fadea7209d53">&#9670;&nbsp;</a></span>calculateHist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, int &gt; &gt; KMC_Lattice::calculateHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the histogram for the input integer data vector using the input bin size. </p>
<p>Linearly spaced bins are automatically created from the minimum value to the maximum value of the data set with the specified bin size. The function outputs bin-centered x values and counts y values in a x-y pair vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the input integer data vector. </td></tr>
    <tr><td class="paramname">bin_size</td><td>is the specified bin size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of x-y pairs consisting of bin-centered x values and counts y values. </dd></dl>

</div>
</div>
<a id="addc79e61f39b75c10f5d9ac3cfc65d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc79e61f39b75c10f5d9ac3cfc65d6d">&#9670;&nbsp;</a></span>calculateProbabilityHist() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::calculateProbabilityHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, int &gt;&gt;&#160;</td>
          <td class="paramname"><em>hist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the probability histogram for the input histogram data vector. The function outputs bin-centered x values and probability y values in a x-y pair vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hist</td><td>is the input histogram data vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of x-y pairs consisting of bin-centered x values and probability y values. </dd></dl>

</div>
</div>
<a id="ae9b5963ba2a0bfe3cd50adbb95738e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b5963ba2a0bfe3cd50adbb95738e8c">&#9670;&nbsp;</a></span>calculateProbabilityHist() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::calculateProbabilityHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the probability histogram for the input integer data vector using the input bin size. </p>
<p>Linearly spaced bins are automatically created from the minimum value to the maximum value of the data set with the specified bin size. The function outputs bin-centered x values and probability y values in a x-y pair vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the input integer data vector. </td></tr>
    <tr><td class="paramname">bin_size</td><td>is the specified bin size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of x-y pairs consisting of bin-centered x values and probability y values. </dd></dl>

</div>
</div>
<a id="a051fca5d8418abdc2189d1751a093561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051fca5d8418abdc2189d1751a093561">&#9670;&nbsp;</a></span>calculateProbabilityHist() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::calculateProbabilityHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the probability histogram for the input double data vector using the input number of bins. </p>
<p>Linearly spaced bins are automatically created from the minimum value to the maximum value of the data set. The function outputs bin-centered x values and probability y values in a x-y pair vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the input data vector. </td></tr>
    <tr><td class="paramname">num_bins</td><td>is the desired number of bins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of x-y pairs consisting of bin-centered x values and probability y values. </dd></dl>

</div>
</div>
<a id="ac52cf3ac9ea9dafde2c32b724f0cedc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52cf3ac9ea9dafde2c32b724f0cedc9">&#9670;&nbsp;</a></span>calculateProbabilityHist() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::calculateProbabilityHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the probability histogram for the input float data vector using the input number of bins. </p>
<p>Linearly spaced bins are automatically created from the minimum value to the maximum value of the data set. The function outputs bin-centered x values and probability y values in a x-y pair vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the input data vector. </td></tr>
    <tr><td class="paramname">num_bins</td><td>is the desired number of bins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of x-y pairs consisting of bin-centered x values and probability y values. </dd></dl>

</div>
</div>
<a id="a4dce0ac44cb8f91ab6ecaf6d40ed25f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dce0ac44cb8f91ab6ecaf6d40ed25f9">&#9670;&nbsp;</a></span>calculateProbabilityHist() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::calculateProbabilityHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bin_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the probability histogram for the input double data vector using the input bin size. </p>
<p>Linearly spaced bins are automatically created from the minimum value to the maximum value of the data set. with the specified bin spacing. The function outputs bin-centered x values and probability y values in a x-y pair vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the input data vector. </td></tr>
    <tr><td class="paramname">bin_size</td><td>is the desired bin size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of x-y pairs consisting of bin-centered x values and probability y values. </dd></dl>

</div>
</div>
<a id="a38c914a7aceae31c54b678dddd04ea84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c914a7aceae31c54b678dddd04ea84">&#9670;&nbsp;</a></span>calculateProbabilityHist() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::calculateProbabilityHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bin_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the probability histogram for the input float data vector using the input bin size. </p>
<p>Linearly spaced bins are automatically created from the minimum value to the maximum value of the data set. with the specified bin spacing. The function outputs bin-centered x values and probability y values in a x-y pair vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the input data vector. </td></tr>
    <tr><td class="paramname">bin_size</td><td>is the desired bin size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of x-y pairs consisting of bin-centered x values and probability y values. </dd></dl>

</div>
</div>
<a id="a0e38c07261ec4b14f0c60020e56d9493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e38c07261ec4b14f0c60020e56d9493">&#9670;&nbsp;</a></span>calculateProbabilityHist() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::calculateProbabilityHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the probability histogram for the input double data vector using the input bin size and input number of bins. </p>
<p>Linearly spaced bins are automatically created starting from the minimum value of the data set. The function outputs bin-centered x values and probability y values in a x-y pair vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the input data vector. </td></tr>
    <tr><td class="paramname">num_bins</td><td>is the number of bins that will be created. </td></tr>
    <tr><td class="paramname">bin_size</td><td>is the input bin size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of x-y pairs consisting of bin-centered x values and probability y values. </dd></dl>

</div>
</div>
<a id="a2cfdace4de266128171220d8814d1adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfdace4de266128171220d8814d1adb">&#9670;&nbsp;</a></span>calculateProbabilityHist() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::calculateProbabilityHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the probability histogram for the input float data vector using the input bin size and input number of bins. </p>
<p>Linearly spaced bins are automatically created starting from the minimum value of the data set. The function outputs bin-centered x values and probability y values in a x-y pair vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the input data vector. </td></tr>
    <tr><td class="paramname">num_bins</td><td>is the number of bins that will be created. </td></tr>
    <tr><td class="paramname">bin_size</td><td>is the input bin size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of x-y pairs consisting of bin-centered x values and probability y values. </dd></dl>

</div>
</div>
<a id="ad56deb6fcc363eed85073043ff129297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56deb6fcc363eed85073043ff129297">&#9670;&nbsp;</a></span>createExponentialDOSVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KMC_Lattice::createExponentialDOSVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>urbach_energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937_64 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector of doubles that has a custom asymmetric distribution with an exponential tail. </p>
<p>The created distribution is Gaussian in the positive direction relative to the mode and exponential in the negative direction. On the Gaussian side, the standard deviation is calculated relative to the Urbach energy chosen for the exponential side, so that the distribution function is continuous. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the data vector where the random numbers will be placed, which must be preallocated to the desired size. </td></tr>
    <tr><td class="paramname">mode</td><td>is the value of the peak of the distribution. </td></tr>
    <tr><td class="paramname">urbach_energy</td><td>is the parameter that determines the shape of the exponential tail side of the distribution. </td></tr>
    <tr><td class="paramname">gen</td><td>is a Mersenne twister random number generator used to randomly draw numbers from the distribution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34ace7172f1130a049e6069ba6d403fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ace7172f1130a049e6069ba6d403fc">&#9670;&nbsp;</a></span>createExponentialDOSVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KMC_Lattice::createExponentialDOSVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>urbach_energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937_64 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector of floats that has a custom asymmetric distribution with an exponential tail. </p>
<p>The created distribution is Gaussian in the positive direction relative to the mode and exponential in the negative direction. On the Gaussian side, the standard deviation is calculated relative to the Urbach energy chosen for the exponential side, so that the distribution function is continuous. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the data vector where the random numbers will be placed, which must be preallocated to the desired size. </td></tr>
    <tr><td class="paramname">mode</td><td>is the value of the peak of the distribution. </td></tr>
    <tr><td class="paramname">urbach_energy</td><td>is the parameter that determines the shape of the exponential tail side of the distribution. </td></tr>
    <tr><td class="paramname">gen</td><td>is a Mersenne twister random number generator used to randomly draw numbers from the distribution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58a253f2ce23a5a608d582a06e67d852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a253f2ce23a5a608d582a06e67d852">&#9670;&nbsp;</a></span>createGaussianDOSVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KMC_Lattice::createGaussianDOSVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>stdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937_64 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector of doubles that has a Gaussian distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the data vector where the numbers will be placed, which must be preallocated to the desired size. </td></tr>
    <tr><td class="paramname">mean</td><td>is the position of the peak and center of the distribution. </td></tr>
    <tr><td class="paramname">stdev</td><td>is the standard deviation of the distribution, which defines the width of the peak. </td></tr>
    <tr><td class="paramname">gen</td><td>is a Mersenne twister random number generator used to randomly draw numbers from the distribution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a224863c8dd449fa501d07c5b0cfc07a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224863c8dd449fa501d07c5b0cfc07a1">&#9670;&nbsp;</a></span>createGaussianDOSVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KMC_Lattice::createGaussianDOSVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>stdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937_64 &amp;&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector of floats that has a Gaussian distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the data vector where the numbers will be placed, which must be preallocated to the desired size. </td></tr>
    <tr><td class="paramname">mean</td><td>is the position of the peak and center of the distribution. </td></tr>
    <tr><td class="paramname">stdev</td><td>is the standard deviation of the distribution, which defines the width of the peak. </td></tr>
    <tr><td class="paramname">gen</td><td>is a Mersenne twister random number generator used to randomly draw numbers from the distribution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b0f0e2e47c9dbe650e4f736c80883c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0f0e2e47c9dbe650e4f736c80883c3">&#9670;&nbsp;</a></span>integrateData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double KMC_Lattice::integrateData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerically integrates a vector of x-y data using the trapezoid rule. </p>
<dl class="section warning"><dt>Warning</dt><dd>The function assumes that the data is sorted by the x values. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the data vector containing x-y data pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the numerically calculated area. </dd></dl>

</div>
</div>
<a id="a04c980223b98303984f9c722356101eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c980223b98303984f9c722356101eb">&#9670;&nbsp;</a></span>interpolateData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double KMC_Lattice::interpolateData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>x_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linearly interpolates an x-y data set to determine the interpolated y-value corresponding to an input x-value. </p>
<dl class="section warning"><dt>Warning</dt><dd>The function assumes that the data is sorted by the x values. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the data vector containing x-y data pairs. </td></tr>
    <tr><td class="paramname">x_val</td><td>is the x-value that will be interpolated to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the interpolated y-value when the input x-value lies within the range of the input data. </dd></dl>

</div>
</div>
<a id="a87d94bc0d678c87d936e14a53c3094ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d94bc0d678c87d936e14a53c3094ff">&#9670;&nbsp;</a></span>intpow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KMC_Lattice::intpow </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function calculates and returns the results of an integer power operation on a base numerical datatype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>is the base of the integer power operation and can be any numerical type. </td></tr>
    <tr><td class="paramname">exponent</td><td>is the integer exponent for the integer power operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the integer power operation in double format. </dd></dl>

</div>
</div>
<a id="ac59934977c80ff0ef20e4108ed0e859a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59934977c80ff0ef20e4108ed0e859a">&#9670;&nbsp;</a></span>MPI_calculatePairVectorAvg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::MPI_calculatePairVectorAvg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses MPI to calculate the average pair vector distribution from separate pair vectors coming from different processors. </p>
<p>Each processor calls this function and sends an input pair vector distribution. Each pair vector entry represents an x-y data pair, where x is the centered bin position and y is the distribution value for that bin. Each input pair vector distribution can have a different range, but they must have the same bin size. Beyond the range of the input pair vector, the y distribution values are assumed to be zero. Upon function return, processor 0 receives the average pair vector and all of the other processors receive an empty pair vector. The range of the final pair vector is automatically sized to contain the data from of all input pair vectors. </p><dl class="section warning"><dt>Warning</dt><dd>This function will throw an invalid_argument exception if any of the input pair vectors have less than two entries </dd>
<dd>
This function will throw an invaid_argument exception if all of the input pair vectors do not have the same bin size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_vector</td><td>is the input pair vector data from the processor calling the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair vector that is the average of all input histograms from each processor, when called on processor 0. </dd>
<dd>
An empty vector when called on other processors. </dd></dl>

</div>
</div>
<a id="acb87c0ce18e46b80e482ab257345f70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb87c0ce18e46b80e482ab257345f70c">&#9670;&nbsp;</a></span>MPI_calculateProbHistAvg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, double &gt; &gt; KMC_Lattice::MPI_calculateProbHistAvg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input_hist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses MPI to calculate the average probability histogram from separate histograms coming from different processors. </p>
<p>Each processor calls this function and sends an input histogram. Each input histogram must have the same bin size.</p>
<p>Upon function return, processor 0 receives the average probability histogram and all of the other processors receive an empty probability histogram. The range of the final pair vector is automatically sized to contain the data from of all input pair vectors. </p><dl class="section warning"><dt>Warning</dt><dd>This function will throw an invalid_argument exception if any of the input histograms have less than two entries </dd>
<dd>
This function will throw an invaid_argument exception if all of the input histograms do not have the same bin size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_hist</td><td>is the input histogram data from the processor calling the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair vector that is the average probability histogram of all input histograms from each processor, when called on processor 0. </dd>
<dd>
An empty vector when called on other processors. </dd></dl>

</div>
</div>
<a id="ad022d008e8635c1285b9b2ca300bd5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad022d008e8635c1285b9b2ca300bd5b6">&#9670;&nbsp;</a></span>MPI_calculateVectorAvg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; KMC_Lattice::MPI_calculateVectorAvg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses MPI to calculate the element-wise average vector from separate vectors coming from different processors. </p>
<p>Each processor calls this function and sends an input vector. If vectors are different sizes, the function uses trailing zeroes to make all vectors the same size before averaging. Upon function return, processor 0 receives the average vector and all of the other processors receive an empty vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_vector</td><td>is the input data from the processor calling the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that is the element-wise average of all input vectors from each processor, when called on processor 0. </dd>
<dd>
An empty vector when called on other processors. </dd></dl>

</div>
</div>
<a id="aa1b88bbdb7d17543f266c0ec41bfc3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b88bbdb7d17543f266c0ec41bfc3b8">&#9670;&nbsp;</a></span>MPI_calculateVectorSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; KMC_Lattice::MPI_calculateVectorSum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses MPI to calculate the element-wise sum vector from separate equally sized vectors coming from different processors. </p>
<p>Each processor calls this function and sends an input vector. Upon function return, processor 0 receives the sum vector and all of the other processors receive an empty vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_vector</td><td>is the input data from the processor calling the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that is the element-wise sum of all input vectors from each processor, when called on processor 0. </dd>
<dd>
An empty vector when called on other processors. </dd></dl>

</div>
</div>
<a id="aafd5796fdd773483e11f6b3e0a954821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd5796fdd773483e11f6b3e0a954821">&#9670;&nbsp;</a></span>MPI_calculateVectorSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; KMC_Lattice::MPI_calculateVectorSum </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses MPI to calculate the element-wise sum vector from separate vectors coming from different processors. </p>
<p>Each processor calls this function and sends an input vector. Upon function return, processor 0 receives the sum vector and all of the other processors receive an empty vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_vector</td><td>is the input data from the processor calling the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that is the element-wise sum of all input vectors from each processor, when called on processor 0. </dd>
<dd>
An empty vector when called on other processors. </dd></dl>

</div>
</div>
<a id="a6b3edfa485575cfb88a6fac4ebec2ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3edfa485575cfb88a6fac4ebec2ee8">&#9670;&nbsp;</a></span>MPI_gatherValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; KMC_Lattice::MPI_gatherValues </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>input_val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses MPI to gather integer values from separate processors to build one vector containing all of the data. </p>
<p>Each processor calls this function and sends an input value. Upon function return, processor 0 receives the data vector and all of the other processors receive an empty vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_val</td><td>is the input integer data value from the processor calling the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that is a collection of the values from each processor, when called on processor 0. </dd>
<dd>
An empty vector when called on other processors. </dd></dl>

</div>
</div>
<a id="add2e9d9c5fa55962da8329cae7787a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2e9d9c5fa55962da8329cae7787a61">&#9670;&nbsp;</a></span>MPI_gatherValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; KMC_Lattice::MPI_gatherValues </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>input_val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses MPI to gather double values from separate processors to build one vector containing all of the data. </p>
<p>Each processor calls this function and sends an input value. Upon function return, processor 0 receives the data vector and all of the other processors receive an empty vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_val</td><td>is the input double data value from the processor calling the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that is a collection of the values from each processor, when called on processor 0. </dd>
<dd>
An empty vector when called on other processors. </dd></dl>

</div>
</div>
<a id="a4d250b1fe5dc4ca3bc72babcede6c664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d250b1fe5dc4ca3bc72babcede6c664">&#9670;&nbsp;</a></span>MPI_gatherVectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; KMC_Lattice::MPI_gatherVectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses MPI to gather vectors from separate processors to build one big vector containing all of the data. </p>
<p>Each processor calls this function and sends an input vector. Upon function return, processor 0 receives the large data vector and all of the other processors receive an empty vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_vector</td><td>is the input data from the processor calling the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that is a concatenation of all input vectors from each processor, when called on processor 0. </dd>
<dd>
An empty vector when called on other processors. </dd></dl>

</div>
</div>
<a id="a2446260a5a686ab9d49f0a765f79bb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2446260a5a686ab9d49f0a765f79bb72">&#9670;&nbsp;</a></span>MPI_gatherVectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; KMC_Lattice::MPI_gatherVectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses MPI to gather vectors from separate processors to build one big vector containing all of the data. </p>
<p>Each processor calls this function and sends an input vector. Upon function return, processor 0 receives the large data vector and all of the other processors receive an empty vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_vector</td><td>is the input data from the processor calling the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector that is a concatenation of all input vectors from each processor, when called on processor 0. </dd>
<dd>
An empty vector when called on other processors. </dd></dl>

</div>
</div>
<a id="a8436fee117116a8b56d91501d4aa6295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8436fee117116a8b56d91501d4aa6295">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; KMC_Lattice::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_k_m_c___lattice_1_1_version.html">Version</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56238d005a2124d1d05e06a927da171d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56238d005a2124d1d05e06a927da171d">&#9670;&nbsp;</a></span>outputVectorToFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KMC_Lattice::outputVectorToFile </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function outputs the input data vector to a file with the specified filename. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function may overwrite existing files if not used carefully. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>is the input data vector. </td></tr>
    <tr><td class="paramname">filename</td><td>is the input file name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99e4511b3bf639f465a6a5ab4511f266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e4511b3bf639f465a6a5ab4511f266">&#9670;&nbsp;</a></span>outputVectorToFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KMC_Lattice::outputVectorToFile </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T, T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function outputs the input data pair vector to a file with the specified filename. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function may overwrite existing files if not used carefully. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>is the input data pair vector. </td></tr>
    <tr><td class="paramname">filename</td><td>is the input file name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5855f0270f9168564452bdc258c0c24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5855f0270f9168564452bdc258c0c24c">&#9670;&nbsp;</a></span>removeDuplicates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void KMC_Lattice::removeDuplicates </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function efficiently removes the duplicate entries from an input vector. </p>
<p>This algorithm allow efficient removal of duplicate vector objects when &gt; or &lt; comparison operators do not exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>is the input vector to be operated on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a142c78315f934d0d4a046faa564621ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142c78315f934d0d4a046faa564621ee">&#9670;&nbsp;</a></span>removeWhitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string KMC_Lattice::removeWhitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all spaces and tab characters in a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>is the input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new string that will have the whitespace removed. </dd></dl>

</div>
</div>
<a id="a106d596e3fdd800dd2bc451ab3a0cc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106d596e3fdd800dd2bc451ab3a0cc92">&#9670;&nbsp;</a></span>round_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int KMC_Lattice::round_int </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rounds the input double value to the nearest integer value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>is the input double value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer value that is the rounded value. </dd></dl>

</div>
</div>
<a id="a82cf4b636d0653f1e68b9035ae63a6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cf4b636d0653f1e68b9035ae63a6f8">&#9670;&nbsp;</a></span>str2bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool KMC_Lattice::str2bool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a boolean value from a string containing "true" or "false". Throws an invalid_argument exception if the input string is not "true" or "false". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>is the input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the input string is "true". </dd>
<dd>
false if the input string is "false". </dd></dl>

</div>
</div>
<a id="ac6e3c50cbe381912063d9a263a1421a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e3c50cbe381912063d9a263a1421a8">&#9670;&nbsp;</a></span>vector_avg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KMC_Lattice::vector_avg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function calculates and returns the average value in double format when given a vector of numerical datatypes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the vector of numerical data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average of the data set in double format. </dd></dl>

</div>
</div>
<a id="a09bbe80a35ef2c48aedb10c350f9281a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bbe80a35ef2c48aedb10c350f9281a">&#9670;&nbsp;</a></span>vector_median()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KMC_Lattice::vector_median </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function calculates and returns the median value when given a vector of numerical datatypes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the vector of numerical data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The median value in the data set. </dd></dl>

</div>
</div>
<a id="a650b567dda3d6dbfc9290ac200af0954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650b567dda3d6dbfc9290ac200af0954">&#9670;&nbsp;</a></span>vector_stdev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double KMC_Lattice::vector_stdev </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function calculates and returns the standard deviation in double format when given a vector of numerical datatypes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the vector of numerical data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The standard deviation of the data set in double format. </dd></dl>

</div>
</div>
<a id="aa5cb31c44a91bf42258b5539fc42563e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cb31c44a91bf42258b5539fc42563e">&#9670;&nbsp;</a></span>vector_which_median()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int KMC_Lattice::vector_which_median </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This template function determines which element in the data vector is closest to the median value of the dataset. </p>
<p>if multiple values are equally close, the first one in the vector is selected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is the input vector of numerical data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integer vector index that indicates the median value. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a91f4a916d9235dfa664004930666c9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f4a916d9235dfa664004930666c9fa">&#9670;&nbsp;</a></span>Current_version</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_k_m_c___lattice_1_1_version.html">Version</a> KMC_Lattice::Current_version</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_k_m_c___lattice.html">KMC_Lattice</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
